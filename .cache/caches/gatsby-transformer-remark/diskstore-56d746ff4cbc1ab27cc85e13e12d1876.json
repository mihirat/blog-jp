{"expireTime":9007200845574950000,"key":"transformer-remark-markdown-html-b9d9f9c4c808eb802ecea21259640f43-gatsby-plugin-sharpgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-emojis-","val":"<p>またGKEネタです。</p>\n<h2>kubernetes clientについて</h2>\n<p>kuberentesをプログラミング言語で操作するためのものです。普段 kubectl コマンドで操作している内容ですね。\nJS, Python, JavaはGAっぽくて、Golang, Haskell, RubyあたりはWIPのようです。\n<a href=\"https://github.com/kubernetes-client\">https://github.com/kubernetes-client</a>\n<a href=\"https://github.com/kubernetes-client/python\">Python製</a>が一番スター数が多く、そろそろ1000くらいですね。</p>\n<p>しかしながら、このチュートリアルが、ローカルから叩く場合くらいしか考慮されてないため、本記事で説明します。</p>\n<h2>What to do</h2>\n<ol>\n<li>k8sクラスタのAPI serverのエンドポイントとCertificateを確認</li>\n<li>k8sのservice accountを作成し、認証Tokenを確認</li>\n<li>Pythonコードからk8s APIを叩く</li>\n</ol>\n<h3>1. k8sクラスタのAPI serverのエンドポイントとCertificateを確認</h3>\n<p>最初完全に勘違いしていたんですが、GKE上にあるk8sクラスタへの接続にGCPのサービスアカウントなどは一切不要です。\nマスターノードやetcdには確かにアクセスできませんが、API serverにさえアクセスできれば操作はできます。\n<a href=\"https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/\">そもそもAPI serverとの接続ってどうなってるのか</a> は説明があるので、一読しておくと良いです。</p>\n<p>ということで、まずクラスタの認証情報などを確認します。\nいずれもGKEのコンソールから確認できます。<a href=\"https://qiita.com/zaru/items/bf5b4e60ad4d67be8bea\">この記事のスクリーンショット</a>がわかりやすいです。</p>\n<h3>2. k8sのservice accountを作成し、認証Tokenを確認</h3>\n<p><a href=\"https://kubernetes.io/docs/reference/access-authn-authz/authentication/\">認証方式は複数ある</a>のですが、手っ取り早いものを採用します。</p>\n<p>k8sの内部にはservice accountというGCPのそれと似た概念があるのですが、このアカウントに適切な権限を付与して利用します。</p>\n<ul>\n<li>ServiceAccount: アカウント</li>\n<li>Role: 権限の定義</li>\n<li>RoleBinding: Roleをアカウントに紐付けるという宣言</li>\n</ul>\n<p>この3つを作成して、権限を持ったアカウントを作成することができます。\nもしクラスタ全体にまたがった操作をする場合（ノードの状態を見る、クラスタ内の全podを確認するなど）は、</p>\n<ul>\n<li>ClusterRole: クラスタ全体に関わる権限の定義</li>\n<li>ClusterRoleBinding: ClusterRoleをアカウントに紐付けるという宣言</li>\n</ul>\n<p>が別に存在します。\n複数のnamespaceが存在する場合は、互いの誤干渉を防ぐため、できるだけnamespaceに閉じた権限を発行するのがよいでしょう。</p>\n<p><a href=\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\">公式を参考</a>に、こんな感じで発行できます。</p>\n<pre class=\"lang:yaml decode:true \">apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: my-k8s-client\n  namespace: my-k8s-ns\nrules:\n- apiGroups: [“”] # “” indicates the core API group\n  resources: [“pods”, “services”]\n  verbs: [“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”]\n- apiGroups: [“extensions”]\n  resources: [“deployments”]\n  verbs: [“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”]\n- apiGroups: [“autoscaling”]\n  resources: [“horizontalpodautoscalers”]\n  verbs: [“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: my-k8s-client\n  namespace: my-k8s-ns\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: my-k8s-client\nsubjects:\n  - kind: ServiceAccount\n    name: my-k8s-client\n    namespace: my-k8s-ns\n</pre>\n<p>Roleだけちょっと面倒なんですが、Resourceが操作したい対象、apiGroupsがそれを操作できるAPIのカテゴリ（documentをめっちゃ見る）、verbsが許可する操作内容です。</p>\n<p>これを <code class=\"language-text\">kubectl apply</code> してservice accountが作成できたら、</p>\n<pre class=\"lang:shell decode:true \">kubectl get secrets --namespace=<namespace_name>kubectl describe secret/</namespace_name></pre>\n<p>で、デプロイしたservice accountのTokenを取得します。<code class=\"language-text\">ey~~~</code> の長い一行の文字列です。</p>\n<h3>3. Pythonコードからk8s APIを叩く</h3>\n<p>準備が全て終わったので、実際にAPIを叩いてみましょう。</p>\n<pre class=\"lang:python decode:true \">from kubernetes import client\nimport yaml\n\n# init\nconfiguration = client.Configuration()\n\n# step2で取得したTokenを記述\nconfiguration.api_key[\"authorization\"] = '<bearer_token>' configuration.api_key_prefix['authorization'] = 'Bearer' # step1で取得したAPI serverのエンドポイント configuration.host = 'https://<ip_of_api_server>' # step1で取得したAPI serverのCertificate。文字列では渡せなさそう configuration.ssl_ca_cert = '<path_to_cluster_ca_certificate>' # api叩くインスタンス生成 v1 = client.CoreV1Api(client.ApiClient(configuration)) # とりあえずpodを見てみる print(v1.list_namespaced_pod(namespace=my-k8s-ns)) # デプロイするときは別のapiインスタンス。まだbetaを使っている deploy_api = client.ExtensionsV1beta1Api(client.ApiClient(configuration)) # 定義したyamlを使ってdeploymentを作成 with open('path/to/deployment.yaml') as f: nice_dict = yaml.load(f) resp = deploy_api.create_namespaced_deployment(body=nice_dict, namespace=my-k8s-ns)</path_to_cluster_ca_certificate></ip_of_api_server></bearer_token></pre>\n<p>pseudo codeですが、だいたいこんなので動作します。\n<code class=\"language-text\">kubectl apply</code> 相当の処理が必要な場合は、<code class=\"language-text\">deploy_api.patch_namespaced_deployment</code> を使って try-exceptして実装します。</p>\n<p>Basic認証などもありますが、チュートリアルには説明がないので<a href=\"https://github.com/kubernetes-client/python/blob/master/kubernetes/client/configuration.py#L84\">実装を見ながら</a>頑張る感じになります。</p>\n<p>チュートリアルの多くは<code class=\"language-text\">config.load_kube_config()</code> を使えばokと結論づけているのですが、\nprogramaticにアクセスするときにはやはり上記の手順を踏むべきかなと思いました。</p>\n<p>なお、今回の記事は\n<a href=\"https://stackoverflow.com/questions/48151388/kubernetes-python-client-authentication-issue\">stackoverflowの投稿</a>を参考に補足などしたものです。\n大変助かりました。</p>"}